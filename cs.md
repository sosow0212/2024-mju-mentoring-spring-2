## 레이어드 아키텍쳐란 
- 소프트웨어를 다양한 층으로 나누어 구축하는 설계 패턴.
- 상위 레이어는 하위 레이어의 서비스를 이용할 수 있음.
- 각 레이어가 책임을 가진다.

### 레이어드 아키텍쳐 구조

- 1. Presentation layer - 사용자 인터페이스 (view) , 웹 통신 프레임워크, CLI 등 인터페이스, 입출력의 변환 등 외부와의 통신을 담당.
  2. Business layer - 핵심 비지니스 로직, 비즈니스 로직을 수행하는 것을 주 관심사로 둔다. 마찬가지로 화면에 데이터를 출력하는 방법이나 혹은 데이터를 어디서, 어떻게 가져오는지에 대한 내용은 알고있지 않는다.
  3. Persistence layer - 영속성 컨텍스트가 여기 속하나??, 어플리케이션의 영속성을 구현하기 위해, 데이터 출처와 그 데이터를 가져오고 다루는 것을 주 관심사로 둔다. 대표적인 구성요소는 Repository, DAO 등이 있음.
  4. Database layer - 데이터 소스 직접 다루는 층


- 각 계층은 캡슐화 되어있고, 의존하지 않으며 단일 책임을 가지고 있다.


### 결론

- 소프트웨어의 복잡성을 관리하고 구조를 명확히 하는데 도움을 줌.
- 효과적인 유지보수, 높은 재사용성, 유연한 설계패턴
---

## 스프링 동작 원리

### 스프링이란?

 - 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크로, 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션.(대규모 작업에 적합하다는 뜻.)
 - 이때, 다른 프레임워크와 다르게 멀티쓰레드 기반임. 이 말은 동시성 문제를 야기할 수 있다는 뜻.

### 스프링 프레임워크 특징

- IoC (Inversion of Control) : 제어의 역행 - 제어의 역행이라는 뜻으로, 소프트웨어 컴포넌트 간의 의존성 관리를 개선하는 디자인 패턴.
  - 스프링 어노테이션.md @Bean 과 @Component 차이점 보면 쉽게 이해 가능.

- DI (Dependency Injection) : 의존성 주입 - 의존성 객체를 개발자가 생성하지 않고 빈으로 등록해두면 스프링 프레임워크가 알아서 찾아 의존성 주입해줄 수 있음. 이를 통해 모듈간의 결합도를 낮출 수 있다.

- AOP (Aspect Oriented Programming) : 관점 지향 프로그래밍 - 핵심 로직 외의 부가적인 횡단 관심사를 모듈화하는 개념.

- POJO (Plane Old Java Object) : 평범한 자바 객체. 자바의 기본적인 객체 지향 프로그램 원칙을 따름.


### MVC 디자인 패턴

- Model : Model은 애플리케이션의 정보, 데이터의 가공을 책임지며 데이터베이스와 상호작용하여 비즈니스 로직을 처리하는 모듈임.
  - View(뷰) 또는 Controller(컨트롤러)에 대해 어떤 정보도 알 수 없어야 함.(의존성에 관한 것)
  - 모델은 재사용이 가능해야 하며 다른 인터페이스에서도 변하지 않아야 함.

- View : View는 클라이언트 단에서 보여지는 결과화면을 반환하는 모듈임.
  - Model(모델)이나 Controller(컨트롤러)에 대한 정보를 알면 안됨.
  - 데이터를 받아 단순히 화면에 표시해주는 역할만.

- Controller : Controller는 client로부터 request가 들어왔을 때 그 입력을 처리하고 어떤 로직을 실행시킬 것인지 Model(모델)과 View(뷰)를 연결해주며 제어하는 모듈임.
  - 모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각각의 구성 요소에게 통지를 해야함.
  - 애플리케이션의 메인 로직을 담당.
---
## 스프링 컨테이너란 무엇인가. 객체와 관리 DI

### 스프링 컨테이너는 스프링 컨테이너는 스프링 프레임워크의 핵심 컴포넌트이다.
- 스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공한다. 스프링에서는 자바 객체를 빈(Bean)이라 한다.
  - 즉, 스프링 컨테이너는 내부에 존재하는 빈의 생명주기를 관리(빈의 생성, 관리, 제거 등)하며, 생성된 빈에게 추가적인 기능을 제공하는 것이다.
    

### 스프링 컨테이너의 기능
- 스프링 컨테이너는 빈(Bean)의 인스턴스화, 구성, 전체 생명 주기 및 제거까지 관리함.
  - 스프링 컨테이너를 통해 원하는 만큼 많은 객체를 가질 수 있다.
  - 스프링 컨테이너는 서로 다른 빈을 연결하여 애플리케이션 빈을 연결하는 역할을 한다.

### 스프링 컨테이너 사용하는 이유
- 일반적으로 자바에서 객체 생성하면 -> new 사용 -> 수많은 객체가 서로 참조 -> 객체지향 프로그램과 맞지 않음
- 따라서 객체 의존성을 낮추어 결합도는 낮추고 높은 캡슐화를 위해 스프링 컨테이너가 사용된다.(DI를 하기 때문에 의존성이 낮아짐)
---
## OS

### 멀티쓰레드는 소켓 통신(TCP)과 C언어 코드를 통해 이해했습니다.

서버란 : 클라이언트의 역할을 하는 프로세스와 소켓을 통해 IPC를 수행하는 것

소켓: TCP소켓(=stream), UDP소켓(=datagram)으로 나뉨

[동작과정]

![TCP 소켓을 사용하는 흐름](mission-racing/서버통신.png)

[TCP 소켓을 사용하는 흐름]

<aside>
💡 TCP 소켓의 핵심은 **accept() 시스템 콜**

</aside>

1. socket() 시스템 콜: 소켓을 만드는 시스템 콜, 미리 형태를 잡아두는 것 / 파일 디스크립터 형식으로 반환. 
- 형식: socket(IPV6, stream, 6(=TCP))

---

2. bind() 시스템 콜: 생성한 소켓에 실제 아이피 주소와 포트 번호 매기는 것(클라이언트는 포트 번호 자동 생성) / bind()시스템 콜은 서버에서만 사용

- 형식: bind(sockfd, sockaddr, socklen_t)
  - sockfd: 바인딩 할 소켓의 파일 디스크립터
  - sockaddr: 소켓에 바인딩 할 아이피 주소, 포트번호를 담은 구조체
  - socklen_t: 위 구조체의 메모리 크기

---

3. listen() 시스템 콜: 연결요청을 대기하는 함수 / Only for TCP

- 파라미터로 받은 backlog 크기만큼 backlog queue를 만드는 시스템 콜!(클라이언트 대기실)
  - 형식: listen(sockfd, backlog)

**서버의 listen 이후  Client의 connect() 시스템 콜 요청: SYN 던짐

---

4. accept() 시스템 콜: 연결요청 수락 함수 / 반환값은 새로운 디스크립트 번호 = ***accept() 함수를 통해 새로 할당받은 소켓을 이용해 데이터 송,수신을 할 수 있는 것***


    왜 새로운 소켓 생성? 
    
    SYN 요청을 보낸 클라이언트가 적어도 하나 있어서 백로그 큐에 있었고 해당 클라이언트의 요청에 대한 이후 응답을 위해 **새로운 소켓을 만들었다.**
    
    형식: int accept(sockfd, sockaddr, socklen_t);
    
    이 listen 시스템 콜이 설정된 이후에 클라이언트의 connect() 요청을 받을 수 있는데, 하나 하나 accept() 해주면 병목 발생 → 멀티 프로세스/ 멀티 쓰레드 이용 : **연결 요청을 받는 부분 따로, 이후 응답까지 주는 부분을 따로 나누게 된다.**
    
    멀티프로세스:  컨텍스트 스위칭을 통해 일어남. 부모에 해당하는 프로세스 작업을 이어오다가, 새로운 자식프로세스를 생성하고 싶은 순간 fork() 함수 호출 
    
    i)fork() == 0: 자식 프로세스 / **마지막에 exit(0) 시스템 콜을 호출(=새로운 응답 안받고 그냥 종료)**
    
    ii) fork() ≠ 0 : 부모 프로세스
    
    이 fork() 함수를 통해 병렬처리를 진행할 수 있다.
    
    멀티 쓰레드:  fork()함수 통해 생성. 프로세스 생성하기 부담스럽고, 컨텍스트 스위칭 하는게 멀티프로세스에서보다 빨라서 만들어짐. 자원을 공유하기 때문에 필연적으로**동시화 문제**가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.
    
    **accept() 시스템 콜 이후에 잔여 3-Way-Handshaking 진행: SYN+ACK → ACK ⇒ Established

<aside>
📢 **서버는 연결을 받는 부분과 응답을 주는 부분이 병렬적으로 이루어져 있다**

</aside>

_- 스프링은 멀티쓰레드 기반이라서 동시 요청에 대해 안전하지가 않다. 즉 필드에 객체나 변수가 선언되면 여러 쓰레드가 접근할 수 있다. 노드는 하나의 쓰레드가 순차적으로 처리되지만 스프링은 그렇지 않다.
  컴퓨터가 자원을 읽을 때 현재 상태를 읽고 값을 바꾸는데 멀티스레드 기반에서 동시에 요청이 오면 값의 일관성이 없어진다.

  - 예를 들어 게시글 좋아요가 100개인 상태에서 동시에 2명이 좋아요를 눌렀을 때 102개가 되어야 하지만 101개가 될 수도 있다는 뜻이다 두 쓰레드가 조회 시점에 100을 읽기 때문에 변경된 값이 적용되지 않는다.

---
## CustomException

### 개요
- 개발을 하다 보면 수많은 Exception 을 만남. 이때, Exception 발생하는 부분을 쉽게 알아채고 코드를 수정하기 위해 CustomException 사용.

### 방법
- 총 4가지의 클래스 존재
  1. CustomErrorCode : Exception이 발생하였을때 알려준 Status 상태와 메시지를 담은 enum 클래스
  2. CustomErrorResponse : 일종의 dto
  3. CustomException : RuntimeException을 상속받은 클래스
  4. CustomExceptionHandler : 일종의 Exception Controller
  
---

## Checked exception vs Unchecked exception

### 자바의 예외처리는 크게 3가지로 나눌 수 있다.

- 에러
  - 시스템에 비정상적인 상황이 발생했을 경우에 발생.
  - 메모리 부족(OutofMemoryError)이나 스택오버플로우(StackOverflowError)와 같이 복구할 수 없는 것.

- 체크 예외
  - RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스.
  - ex) 존재하지 않는 파일의 이름을 입력(FileNotFoundException), 실수로 클래스의 이름을 잘못 적음(ClassNotFoundException)
  - 반드시 예외 처리 함.
  - Rollback이 되지 않고, 트랜젝션이 commit까지 완료.
  
- 언체크 예외
  - RuntimeException의 하위 클래스, 실행 중에 발생할 수 있는 에러.
  - ex) 배열의 범위를 벗어난(ArrayIndexOutOfBoundsException), 값이 null이 참조변수를 참조(NullPointerException)
  - 명시적인 예외처리 강제하지 않음.
  - Rollback 함.

---
## 직렬화와 역직렬화 

### 직렬화란?

- 객체들의 데이터를 연속적인 데이터(스트림)로 변형하여 전송 가능한 형태로 만드는 것.

### 역직렬화란? 

- 직렬화된 데이터를 다시 객체의 형태로 만드는 것.
  
더 공부 필요..

---
## [스프링] 싱글톤 방식의 주의점 : 스프링 빈은 항상 무상태로 설계할 것.
- 스프링 빈으로 등록되는 클래스는 공유가 될 수 있는 전역 변수를 사용하면 안된다.
- 싱글톤으로 빈 객체를 유지하는 스프링 컨테이너 특성 상 멤버 변수를 두게 되면 다른 곳에서 그 상태를 유지한 채 재사용 될 수 있음.
  - 서로 다른 요청에 따라 스레드가 각자의 스택 메모리를 차지한다고 해도 힙 영역은 이미 빈 객체가 로딩되어 있음. -> 꼬인다.
- 따라서, 빈 객체는 메서드를 공유하는 역할을 해야하며, 필드 값이 없는 무상태로 설계해야 한다.

---

## SOLID 원칙 

### SOLID 원칙은 객체 지향 설계의 5가지 기본 원칙을 나타내는 약어이다.

1. Single Responsibility Principle(단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 하는 원칙
2. Open-Closed Principle(개방-폐쇄 원칙) : 소프트웨어 구성요소(클래스, 모듈 등)는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다는 원칙(기존의 코드를 변경하지 않고도 기능을 추가할 수 있어야 함.)
3. Liskov Substitution Principle(리스코프 치환 원칙) : 서브 타입은 언제나 그것의 베이스 타입으로 교체할 수 있어야 한다는 원칙
4. Interface Segregation Principle(인터페이스 분리 원칙) : 자신이 사용하지 않는 인터페이스에는 의존하면 안된다는 원칙
5. Dependency Inversion Principle(의존성 역전 원칙) : 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다는 원칙

* SOLID 개발의 장점
  1. 유지보수 용이
  2. 확장성 높음
  3. 유연한 소프트웨어 만들 수 있음

---

## 스프링과 JSON

### 스프링은 Jackson 라이브러리를 통해 JSON으로 값을 주고 받을 수 있음. 이때 직렬화와 역직렬화 개념이 필요.(JsonAnnyGetter..)

---

## 생성자에 매개변수가 많다면 빌더 패턴을 고려할 것 (이펙티브 자바)

* 생성자와 정적 팩터리 메서드는 매개변수가 많을 때 적절히 대응하기 어렵다는 단점이 있음.

### 점층적 생성자 패턴 (telescoping constructor pattern)

* 필수 매개변수를 받는 생성자 1개, 그리고 선택매개변수를 하나씩 늘여가며 생성자를 만드는 패턴 - 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 선택 매개변수를 2개까지 받는 생성자, ... 형태로 선택 매개변수를 전부 다 받는 생성자까지 늘려가는 방식이다.

* 단점:
  1. 초기화하고 싶은 필드만 포함한 생성자가 없다면, 설정하길 원치 않는 필드까지 매개변수에 값을 지정해줘야 한다.
  2. 복잡하고 읽기 어렵다.

* 매개변수가 많아졌을 떄의 문제점이 있음.

### 자바빈 패턴 (JavaBeans pattern)

* 매개변수가 없는 생성자로 객체를 만든 후, setter 메서드를 호출해 원하는 매개변수 값을 설정하는 방식.

* 단점: 
  1. 객체 하나를 만들려면 메서드를 여러 개 호출해야 한다.
  2. 객체가 완성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.


### 빌더 패턴

* Builder를 이용해 필수 매개변수로 객체를 생성하고, 일종의 setter를 사용하여 선택 매개변수를 초기화한 뒤
  build() 메서드를 호출하여 완전한 객체를 생성하는 패턴.

* 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수 만으로 생성자(혹은 정적 팩터리)를 호출해 빌더 객체를 얻음.

* 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 겸비.

* 빌더 패턴은 객체 생성 선에 setter를 통해 값을 넣기 때문에 불변하고, 또한 안정성이 있다.

---

## Optional

### Optional 이란 
* null이 올 수 있는 값을 감싸는 Wrapper 클래스로, 참조하더라도 NPE가 발생하지 않도록 도와주는 클래스이다.

### 안티패턴이란? 
* 안티패턴은 실제 많이 사용되는 패턴이지만 비효율적이거나 비생산적인 패턴을 의미한다. 안티패턴은 성능, 디버깅, 유지보수, 가독성등에 있어 부정적인 영향을 줄 수 있기 때문에 지양해야하는 패턴이다.

### Optional 안티패턴
* 필드로 사용금지
  * Optional은 Serializable를 구현하지 않기 때문에 필드로 사용하면 안된다.
  
* isPresent()-get() 대신 orElse(), orElseGet(), orElseThrow() 사용하기

* Optional을 생성자나 메서드 파라메터로 사용금지

* orElse() 대신 orElseGet(), orElseThrow() 사용하기

---

## 일반 객체로 선언하는 것과 빈으로 등록하는 것의 차이

1. 생성 및 관리
   - 일반 객체: 개발자가 명시적으로 객체를 생성하고 관리해야 한다. 객체 생성 시 의존성 주입, 라이프사이클 관리, 초기화 및 소멸 작업을 수동으로 처리해야 함.
   - 빈 객체: Spring 컨테이너에 의해 관리. Spring이 빈의 생성, 의존성 주입, 라이프사이클 관리, 초기화 및 소멸 작업을 자동으로 처리한다.

2. 의존성 주입 (Dependency Injection):
   - 일반 객체: 의존성을 직접 코드 내에서 주입해야 함. 
   - 빈 객체: Spring이 자동으로 의존성을 주입. 생성자 주입, 세터 주입, 필드 주입 등 다양한 방식으로 주입할 수 있다.

3. 스코프:
   - 일반 객체: 객체의 스코프를 직접 관리해야 함. (싱글톤, 프로토타입 등)
   - 빈 객체: Spring이 빈의 스코프를 관리한다. 기본적으로 싱글톤 스코프이지만, 다른 스코프(프로토타입, 요청, 세션 등)로 설정할 수 있음.


## 언제 빈으로 등록하는 것이 좋을까 ? 

1. 의존성 주입이 필요한 경우 
2. 객체의 스코프가 중요한 경우_

---

## 스코프란 무엇인가

- 스코프는 객체가 생성되고 유지되는 범위를 의미한다.
- 따라서, 빈 스코프는 Spring 컨테이너에서 빈 객체가 어떻게 생성되고 관리되는지를 정의하는 개념임.

### 스프링 빈 스코프의 종류 

1. Singleton (기본값)
   - 정의: Spring 컨테이너 당 한 개의 인스턴스만 생성하여 공유하는 스코프.
   - 특징: 모든 요청에서 동일한 빈 인스턴스를 반환.
   - 사용: 상태를 유지하지 않고, 여러 곳에서 공통으로 사용되는 빈에 적합.
   - 설정: 별도의 설정이 없으면 기본적으로 싱글톤 스코프가 적용.

2. Prototype
   - 정의: 요청할 때마다 새로운 인스턴스를 생성하는 스코프.
   - 특징: 각 요청에서 새로운 빈 인스턴스를 반환.
   - 사용: 상태를 유지해야 하거나, 각 사용자가 독립적인 빈 인스턴스를 필요로 하는 경우에 적합.
   - 설정: @Scope("prototype") 어노테이션을 사용.

3. Request 
   - 정의: HTTP 요청마다 하나의 인스턴스를 생성하고, 요청이 끝나면 소멸되는 스코프.
   - 특징: 웹 애플리케이션에서 각 HTTP 요청마다 빈이 생성되고 소멸.
   - 사용: 요청마다 다른 데이터를 처리해야 하는 경우에 적합.
   - 설정: @Scope("request") 어노테이션을 사용.

### 스코프와 빈의 사용

- 싱글톤 빈은 애플리케이션 전체에서 하나의 인스턴스를 공유하기 때문에 메모리 사용을 줄이고 초기화 비용을 최소화할 수 있음 but 상태를 유지해야 하는 빈에는 적합하지 않다. 
- 프로토타입 빈은 요청마다 새로운 인스턴스를 생성하므로 메모리 사용이 증가할 수 있지만, 상태를 개별적으로 유지할 수 있다.

---

## 싱글톤이란 무엇인가..

* 싱글톤 패턴은 소프트웨어 디자인 패턴 중 하나로, 한 클래스의 인스턴스가 오직 하나만 생성되고, 그 인스턴스에 전역적으로 접근할 수 있도록 하는 패턴.
* 이해 안간다면 => A,B,C 사용자가 똑같은 객체의 이름만 A,B,C로 달아 자기 것을 쓰면 다른 사람들이 자신의 자원을 건들 일이 없지만 A,B,C 사용자가 싱글톤 객체 T 하나만 이용한다면 T의 필드는 이곳저곳에서 건들여 정합성 보장이 되지 않는다.(멘토님 코드리뷰)

## 싱글톤 패턴의 특징
- 유일한 인스턴스: 클래스의 인스턴스가 하나만 존재하도록 보장.
- 전역 접근: 애플리케이션 어디서나 이 인스턴스에 접근할 수 있음.
- 메모리 절약: 객체를 한 번만 생성하므로 메모리를 절약할 수 있다.
- 상태 공유: 애플리케이션의 모든 부분에서 동일한 상태를 공유할 수 있다.

## 싱글톤의 장단점

장점
- 메모리 절약: 객체를 하나만 생성하므로 메모리를 절약할 수 있다.
- 일관된 접근: 모든 클래스에서 동일한 인스턴스에 접근할 수 있어 일관성을 유지할 수 있다.
- 리소스 관리: 데이터베이스 연결이나 설정 파일 등 공유 자원을 관리하기에 적합.

단점
- 테스트 어려움: 싱글톤은 전역 상태를 가지므로 단위 테스트가 어려울 수 있다.(공유하기 때문)
- 의존성 문제: 다른 클래스와 강하게 결합될 수 있음.
- 멀티스레드 이슈: 잘못 구현된 싱글톤은 멀티스레드 환경에서 문제가 발생할 수 있다.(멘토님이 계속 말씀하시던 것)


##  스프링에서 왜 기본 빈 스코프를 싱글톤으로 설정하였을까

- Spring에서 기본 빈 스코프를 싱글톤으로 설정한 것은 성능, 메모리 효율성, 일관성 유지, 설계의 단순화, 전역 상태 관리, 그리고 검증된 디자인 패턴의 장점을 종합적으로 고려한 결과이다.
---

## RestFul 과 HTTP 메서드

### REST 란? 
* REST(Representational State Transfer) 네트워크 아키텍처 원칙을 기반으로 한 웹 서비스 디자인 방식이다. REST 는 리소스를 기반으로 한 설계 철학을 따르며, 이러한 리소스는 URI을 통해 식별된다. --> 쉽게 말해, REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이고, 이미지나 텍스트 같은 자원들을 JSON 혹은 XML 형식으로 URL 통해 주고 받는 것.

#### REST 의 주요원칙
* Client–server 구조 : 클라이언트와 서버는 서로 독립적이어야 하며, 클라이언트는 url만 알아야 한다. 그리고, 클라이언트와 서버의 인터페이스가 변경되지 않는 한, 이 둘은 독립적으로 개발되거나 대체될 수 있게 유지해야한다. (관심사의 명확한 분리).
* Stateless(무상태성) : 각 요청은 독립적이며, HTTP 요청에 대한 어떤 것도 저장하지 않는다.(필수적인 것 빼고) 클라이언트의 모든 정보는 요청에 포함되어야 한다.
* Cacheable : 서버는 Response cache-control 헤더에 해당 요청이 캐싱이 가능한 지에 대한 여부를 제공해야 한다. 클라이언트는 Response를 캐싱하여 서버와 클라이언트 간의 상호작용을 줄이고, 성능과 서버 가용성을 늘릴 수 있음.
* Layered system(다중 계층): REST는 다중 계층 구조를 가질 수 있도록 허용한다.(API 서버와 데베 서버 따로 두는 느낌)  레이어는 자기와 통신하는 컴포넌트 외 레이어에 대해서는 정보를 얻을 수 없다.
* Code on demand (optional): 서버가 클라이언트에서 실행시킬 수 있는 로직을 전송하여 클라이언트의 기능을 확장시킬 수 있다. 이를 통해 클라이언트가 사전에 구현해야하는 기능의 수를 줄여 간소화시킬 수 있다.
* Uniform interface(일관된 인터페이스) : 
  * identification of resources : 요청 시 개별 자원을 식별할 수 있어야함
  * manipulation of resources through representations : 어떤 자원에 대헤 작업하기 위한 적절한 표현과 메타데이터를 충분히 갖추고 있다면, 서버는 해당 자원을 변경, 삭제할 수 있는 정보를 가지고 있단 의미
  * self-descriptive messages : 자신을 어떻게 처리해야하는지 정보를 포함해야함
  * hypermedia as the engine of application state : 단순히 결과 뿐만이 아니라 결과에 대한 정보를 포함해야 함
    
### HTTP 메서드란? 
* 클라이언트와 서버 간의 통신에서 사용된다. 각 메서드는 특정한 작업을 수행하며, RESTful 서비스에서 리소스 조작을 위해 주로 사용됨. HTTP 메서드는 CRUD(Create, Read, Update, Delete) 기능을 제공.

1. GET - 서버에서 리소스를 조회. 
   * 안전성: 서버 상태를 변경하지 않는다.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   * 캐싱: GET 요청은 캐싱할 수 있다.

2. POST - 서버에 새로운 리소스를 생성. 
   * 안전성: 서버 상태를 변경.
   * 멱등성: 동일한 요청을 여러 번 수행하면 여러 개의 리소스가 생성될 수 있음.
   * 캐싱: 일반적으로 캐싱하지 않음.

3. PUT - 서버의 기존 리소스를 업데이트합. 주로 전체 수정. 
   * 안전성: 서버 상태를 변경.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   * 캐싱: 캐싱할 수 있음.

4. PATCH - 서버의 기존 리소스를 부분적으로 업데이트. 
   * 안전성: 서버 상태를 변경.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   * 캐싱: 일반적으로 캐싱하지 않음.

5. DELETE - 서버에서 리소스를 삭제. 
   * 안전성: 서버 상태를 변경.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   * 캐싱: 일반적으로 캐싱하지 않음.

6. HEAD - GET 요청과 동일하지만, 응답 본문을 포함하지 않음. 리소스의 메타데이터(헤더)만 반환. 
   * 안전성: 서버 상태를 변경하지 않음.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   * 캐싱: 캐싱할 수 있다.

7. OPTIONS - 서버가 지원하는 HTTP 메서드를 확인. 
   * 안전성: 서버 상태를 변경하지 않음.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.
   
8. TRACE - 요청이 서버에 도달하는 과정을 추적. 
   * 안전성: 서버 상태를 변경하지 않음.
   * 멱등성: 동일한 요청을 여러 번 수행해도 결과가 동일.

### HTTP 상태 코드
* HTTP 상태 코드:
  * 200 OK: 요청이 성공적으로 처리되었습니다.
  * 201 Created: 리소스가 성공적으로 생성되었습니다.
  * 204 No Content: 요청이 성공적으로 처리되었으나 반환할 데이터가 없습니다.
  * 400 Bad Request: 잘못된 요청입니다.
  * 401 Unauthorized: 인증이 필요합니다.
  * 403 Forbidden: 권한이 없습니다.
  * 404 Not Found: 요청한 리소스를 찾을 수 없습니다.
  * 500 Internal Server Error: 서버에서 오류가 발생했습니다.

### URL 설계
* 리소스: URI는 리소스를 표현. ex) 사용자를 표현하는 URI = /members.
* 컬렉션: 복수형 명사를 사용하여 리소스 컬렉션을 표현. ex) /members (모든 사용자)
* 리소스 인스턴스: 특정 리소스를 표현하기 위해 식별자를 사용. 예: /members/123 (ID가 123인 사용자)

### RestAPI 설계 규칙
1. URI는 정보의 리소스를 표현.
   * 행위에 대한 표현이 아닌 리소스 표현하는데 중점을 두어야 한다, 리소스명은 동사보다는 명사를 사용한다.
2. 리소스에 대한 행위는 HTTP Method로 표현.
3. 슬래시 구분자(/)는 계층 관계를 나타내는데 사용.
4. URI 마지막 문자로 슬래시(/)를 포함 X
5. 하이픈(-)은 URI 가독성을 높이는데 사용
   * URI를 쉽게 읽고 해석하기 위해, 불가피하게 긴 URI 경로를 사용하게 된다면 하이픈을 사용해 가독성을 높일 수 있음.
6. 언더바(_)는 URI에 사용 X
7. URI 경로에는 소문자를 사용.
   * 대소문자에 따라 다른 리소스로 인식하기 때문.
8. 파일 확장자는 URI에 포함 X

   
### RestFul 이란?
* RESTful 서비스는 REST 원칙을 준수하는 웹 서비스.
---
## JPA란 무엇인가? 
* JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준이다. 애플리케이션과 JDBC 사이에서 동작한다.


### ORM이란 무엇인가?
* Object-Relational Mapping 이름 그대로 객체와 관계형 데이터 베이스 매핑한다는 뜻.
* ORM 프레임워크는 객체와 테이들블 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결.
  * ex) 개발자가 insert SQL문을 직접 작성하는 것이 아니라, 객체르 자바 컬렉션에 저장하듯 ORM 프레임워크에 저장하면 됨. -> ORM 프레임워크가 자동 매핑.
* 자바 진영의 대표적인 ORM 프레임 워크 : Hibernate


### JPA를 사용하는 하는 이유
1. 생산성
    * 지루하고 반복적인 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다.
    * Create Table 같은 DDL 문을 자동으로 생성해주는 기능 있음

2. 유지보수
    * SQL 직접 다루면 엔티티에 필드 하나 추가만 해도 관련된 JDBC API 수정해야 함. But JPA 사용하면 JPA가 대신 처리. => 유지보수 해야하는 코드 줄어듦.
    * 패러다임 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점을 활용해서 유지보수하기 좋은 도메인 모델을 편리하게 설계

3. 패러다임의 불일치 해결
    * 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결.
      * 상속 : 
        * JDBC API 사용하면 부모 객체 데이터 꺼내오는 코드, 자식 객체 데이터 꺼내오는 SQL 코드 다 만들어야함. => JPA 사용하면 해결
        * 자바 컬렉션에 저장하듯 JPA에 객체를 저장하면 됌. ex) jpa.persist()
      * 연관관계 : 참조로 연관관계 맺을 수 있음 -> 저장, 조회 등  기능 할때 참조로 해결 가능. ex) entity에 Team team 선언. 외래 키 선언 필요 X.
      * 객체 그래프 탐색(참조를 사용해 연관된 팀 찾는 것): 
        * SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐. => 개발자에게 너무 큰 제약(SQL에 의존적인 개발)
        * JPA 사용하면 객체 그래프 마음껏 탐색 가능. 지연로딩(필요한 시점에 데이터를 꺼내오는 것)을 투명하게 처리.
      * 비교 : 
        * 테이블은 기본 키의 값으로 row 구분 - 객체는 동일성(==)과 동등성(equals)을 구분
        * JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장함. 

4. 성능
    * JPA는 애플리케이션과 데이터베이스 사이에서 작동 -> 최적화 관점에서 시도해 볼 수 있는 것이 많음.

5. 데이터 접근 추상화와 벤더 독립성
    * 관계형 데이터 베이스는 같은 기능도 벤더마다 사용법이 다른 경우 많이 있음.(ex) 페이징, 데이터베이스 마다 페이징 처리 기법이 달라서 따로 따로 익혀야 함) -> JPA 사용하면 데이터 베이스 변경할 때 다른 데이터베이스를 사용한다고 알려주기만 하면 문제 해결.
  
  
### JPA를 사용하는 원리
* 자바 객체와 데이터베이스 테이블 간의 매핑을 통해 객체지향 프로그래밍의 장점을 유지하면서 데이터베이스와 상호작용한다. 엔티티, 엔티티 매니저, 영속성 컨텍스트, JPQL을 통해 데이터의 생성, 조회, 업데이트, 삭제 작업을 수행.

#### JPA 자세한 원리
1. 엔티티 매니저 팩토리에서 엔티티 매니저 생성 -> 엔티티 매니저 내부에 영속성 컨텍스트 같이 만들어짐.(영속성 컨텍스트는 엔티티 매니저를 통해 접근 가능)
2. 영속성 컨텍스트가 가상의 데이터베이스 같은 역할을 수행 -> 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경감지, 지연 로딩 사용 가능.
3. 영속성 컨텍스트에 저장한 엔티티 플러시 통해 데베 반영 (일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트 플러시)

* 엔티티 매니저란?
   * 엔티티를 저장, 수정, 조회, 삭제하는 등 엔티티와 관련된 모든 일 처리
   * 말 그대로 엔티티를 관리하는 관리자다.
   * 영속성 컨텍스트 사용(엔티티를 영구 저장하는 환경 이라는 뜻.) => 영속성 컨텍스트에 엔티티를 저장하거나 조회하고 보관한다.

* 엔티티 매니저 팩토리와 엔티티 매니저 
  * 데이터베이스 사용하는 애플리케이션은 일반적으로 하나의 엔티티 매니저 팩토리 생성. => 필요할 때마다 엔티티 매니저 펙토리에서 엔티티 매니저 생성
    * **중요** 엔티티 매니저 팩토리는 여러 스레드가 동시에 공유해도 안전 BUT 엔티티 매니저는 여러 스레드 동시 접근 시 동시성 문제 발생
  
* 엔티티의 생명주기
  1. 비영속 : 영속성 컨텍스트와 관계가 없는 상태
  2. 영속 : 영속성 컨텍스트에 저장된 상태 -> 엔티티가 영속성 컨텍스트에 의해 관리된다는 뜻
  3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태 -> 이에 해당하는 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.
  4. 삭제 : 삭제된 상태

* 영속성 컨텍스트의 특징
  1. 영속성 컨텍스트와 식별자 값
     * 영속상태는 식별자가 반드시 있어야 함.(엔티티를 식별자로 구별 -> 없으면 예외 발생)
  2. 플러시를 통해 영속성 컨텍스트 안에 있는 엔티티를 데베에 저장
  3. 장점
     * 1차 캐시 지원
     * 동일성 보장
     * 트랜잭션을 지원하는 쓰기 지연
     * 변경 감지
     * 지연 로딩

### JPA 특징
1. 객체-관계 매핑(ORM)
   * 엔티티는 데이터베이스 테이블에 매핑되며, 필드는 테이블의 열에 매핑.

2. 투명한 데이터 접근
   * 엔티티 매니저를 통해 데이터베이스 접근이 이루어지므로, 데이터베이스 종속성을 줄일 수 있다.

3. 캐싱 
   * JPA는 1차 캐시를 통해, 동일한 트랜잭션 내에서 동일한 엔티티에 대한 중복 조회를 방지.
   * 2차 캐시를 통해 애플리케이션 전반에 걸쳐 엔티티를 캐싱할 수 있음.

4. 자동화된 DDL 생성 
   * 엔티티 클래스의 매핑 정보를 기반으로 데이터베이스 테이블을 자동으로 생성 및 변경할 수 있음.
   * 개발 초기 단계에서 데이터베이스 스키마를 쉽게 설정.

5. 트랜잭션 관리 
   * JPA는 트랜잭션 관리를 제공하여, 데이터베이스 작업의 원자성, 일관성, 고립성, 지속성을 보장.
   * 엔티티 매니저의 트랜잭션을 통해 데이터 무결성을 유지.

6. 지연로딩과 즉시로딩

---
## 계층형 패키지 구조 vs 도메인형 패키지 구조

* 계층형 패키지 구조
~~~
controller
	⎿ UserController
	⎿ LottoController	

service
	⎿ UserService
	⎿ LottoService
	
dto ...
domain ...
~~~
1. 패키지만 보면 전체적인 구조 파악 가능
2. 계층별 응집도 상승
3. but 도메인별 응집도는 낮다.(하나의 패키지 안에 여러 도메인이 섞여있음.)
4. 규모가 커지면 가시성이 떨어진다


* 도메인형 패키지 구조
~~~
User
   ⎿ UserController
   ⎿ UserService
   ⎿ UserDto
    ...

Lotto
   ⎿ LottoController
   ⎿ LottoService
   ⎿ LottoDto
    ...
~~~
1. 도메인별 응집도가 높아진다.
2. 유스케이스별로 세분화해서 표현 가능
3. but 전반적인 흐름은 파악하기 어렵다.
4. 개발자 관점에 따라 패키지 두는 위치가 바뀔 수 있음.

### 결론
* 정답은 없지만 프로젝트 규모가 커지면 도메인 패키지 구조가 유리함.
---

## Spring 예외 처리 


* @Controller 및 @ControllerAdvice 클래스는 컨트롤러 메서드에서 발생하는 예외를 처리하기 위해 @ExceptionHandler 메서드를 가질 수 있다.
~~~
@Controller
public class SimpleController {

    // ...

    @ExceptionHandler
    public ResponseEntity<String> handle(IOException ex) {
        // 예외 처리 로직
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("IOException occurred: " + ex.getMessage());
    }
}
~~~

### ControllerAdvice
* @ControllerAdvice와 @RestControllerAdvice는 예외 처리, 데이터 바인딩, 모델 속성 설정 등의 기능을 글로벌하게 적용하기 위해 사용되는 기능.

#### 기본 원리
* @ExceptionHandler, @InitBinder, @ModelAttribute 메서드는 선언된 @Controller 클래스(또는 클래스 계층) 내에서 적용. 이러한 메서드를 전역적으로(여러 컨트롤러에 걸쳐) 적용하고자 할 경우, @ControllerAdvice 또는 @RestControllerAdvice 어노테이션이을 붙여 클래스 선언 가능.
* @ControllerAdvice는 @Component로도 어노테이트되어 있으므로, 컴포넌트 스캐닝을 통해 스프링 빈으로 등록될 수 있다.
* @RestControllerAdvice는 @ControllerAdvice와 @ResponseBody가 결합된 어노테이션으로, @ExceptionHandler 메서드를 메시지 변환을 통해 응답 본문으로 렌더링한다.

#### 동작 방식
* 애플리케이션 시작 시, @RequestMapping 및 @ExceptionHandler 메서드에 대한 클래스는 @ControllerAdvice로 어노테이트된 스프링 빈을 감지하고, 런타임에 해당 메서드를 적용. 전역 @ExceptionHandler 메서드(즉, @ControllerAdvice에서 선언된 메서드)는 로컬 메서드(즉, @Controller에서 선언된 메서드) 이후에 적용된다(Controller 예외 먼저, 이후 ControllerAdvice 예외 적용). 반면, 전역 @ModelAttribute 및 @InitBinder 메서드는 로컬 메서드 이전에 적용.

```적용 범위 좁히기```
* 기본적으로 @ControllerAdvice 메서드는 모든 요청(모든 컨트롤러)에 적용된다. 그러나 애노테이션의 속성을 사용하여 특정 컨트롤러의 하위 집합에만 적용되도록 범위를 좁힐 수 있다.

~~~
// @RestController로 어노테이트된 모든 컨트롤러를 대상으로 함
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// 특정 패키지 내의 모든 컨트롤러를 대상으로 함
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// 특정 클래스에 할당 가능한 모든 컨트롤러를 대상으로 함
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
~~~

### ExceptionHandler
* @ExceptionHandler 메서드는 컨트롤러 메서드에서 발생하는 특정 예외를 처리할 수 있다.
* @RestControllerAdvice와 함께 사용하여 전역 예외 처리를 구현할 수 있음.
* 메서드 인수: @ExceptionHandler 메서드는 @RequestMapping 메서드와 동일한 메서드 인수를 지원.
* 반환 값: @ExceptionHandler 메서드는 @RequestMapping 메서드와 동일한 반환 값을 지원.

---

## Entity - 기본 생성자 필요한 이유
* 기본 생성자가 존재하지 않는다면 DB에서 조회해 온 값을 엔티티로 만들 때 객체 생성 자체가 실패함. (JPA가 엔티티를 인스턴스화할 때 리플렉션(Reflection)을 사용하기 때문.)

``리플랙션이란? - 자바 프로그래밍 언어에서 런타임에 클래스, 인터페이스, 메서드, 필드 등의 구조를 검사하고 조작할 수 있는 기능을 의미.``

### 기본 생성자의 접근 제어자는 어떤 것을 써야 할까?
* 결론 : protected
  * lombok 의 @NoArgsConstructor(access = AccessLevel.PROTECTED)를 엔티티 클래스 위에 선언함으로 간단하게 생성자를 사용

1. private 사용했을 경우 : 리플랙션 사용할 때 접근 자체가 불가능 -> JPA는 프록시 기술을 사용하는데 거기서 프록시 기술을 쓸 때, jpa hibernate가 객체를 강제로 만들어야하는데 private 로 만들어보리면 막혀버림.
2. public 사용했을 경우 : 
   * public을 사용하면 setter 사용 가능 -> 객체의 일관성을 보장 X
   * 모든 클래스가 User 엔티티를 자유롭게 인스턴스화할 수 있게 됨 -> 캡슐화 위반

---

## Transaction(트랜잭션)
* 트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻함.

### 트랜잭션의 특징
1. 원자성 (Atomicity) 
   * 트랜잭션 내의 모든 명령이 모두 수행되어야 하며, 하나라도 수행 안될 경우 트랜잭션 모두 취소 => 롤백
2. 일관성 (Consistency)
   * 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유자.
3. 격리성 (Isolation)
   * 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
4. 지속성 (Durability)
   * 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점
     
   
### 트랜잭션 연산 및 상태 

#### 연산
* Commit 연산 : 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
* Rollback 연산 : 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산 => Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기.

#### 상태
* 활동(Active) : 트랜잭션이 실행중인 상태
* 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
* 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
* 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
* 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태


### @Transactional
* @Transactional 어노테이션은 트랜잭션의 범위와 설정을 정의하는 데 사용 , 트랜잭션이 성공적으로 완료되면 커밋되고, 예외가 발생하면 롤백됨.
* 사용법 : 클래스에 적용(클래스에 해당하는 메서드 모두 적용), 메서드 적용.(둘 다 적용된 경우에는 메서드에 적용된게 우선순위 높음)

#### 트랜잭션 설정

1. propagation: 트랜잭션 전파 방식을 정의. (기본값: REQUIRED)
2. isolation: 트랜잭션 격리 수준을 정의. (기본값: ISOLATION_DEFAULT)
3. timeout: 트랜잭션 타임아웃을 초 단위로 설정. (기본값: 없음)
4. readOnly: 읽기 전용 트랜잭션 여부를 설정. (기본값: false)
5. rollbackFor: 롤백을 유발할 예외 타입을 지정.
6. noRollbackFor: 롤백을 유발하지 않을 예외 타입을 지정.

---

## JPA : 데베 상호작용을 위한 특징

### 쓰기 지연 (Write-Behind/Write-Delay)
* 쓰기 지연은 JPA가 엔티티에 대한 변경 사항을 즉시 데이터베이스에 반영하지 않고, 트랜잭션이 커밋될 때까지 변경 사항을 보류하는 기능. => 데이터베이스와의 상호작용 횟수를 줄여 성능을 최적화.

### 더티 체킹 (Dirty Checking)
* 더티 체킹은 JPA가 엔티티의 상태 변화를 감지하여 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영하는 기능. 엔티티의 속성 값이 변경되면, JPA는 이를 감지하고 필요한 업데이트 쿼리를 생성하여 데이터베이스에 반영.

### 1차 캐시 (First-Level Cache)
* 영속성 컨텍스트는 1차 캐시 역할을 함. 동일한 트랜잭션 내에서 동일한 엔티티를 여러 번 조회할 때, 데이터베이스를 다시 조회하지 않고 1차 캐시에서 엔티티를 반환 => 이렇게 하면 데이터베이스 접근 횟수를 줄이고 성능을 향상(최적화).

### 지연 로딩 (Lazy Loading)과 즉시 로딩 (Eager Loading)
* 엔티티 간의 연관 관계를 로딩할 때, JPA는 지연 로딩과 즉시 로딩을 제공. 
  * 지연 로딩은 실제로 연관된 엔티티가 필요할 때까지 로딩을 지연시키는 방식. 
  * 즉시 로딩은 엔티티를 조회할 때 연관된 엔티티도 즉시 로딩하는 방식.

### JPQL (Java Persistence Query Language)
* JPQL은 SQL과 유사한 구문을 사용하여 엔티티 객체를 조회하기 위한 쿼리 언어. JPQL은 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성.
* gpt 예제
~~~
public List<User> findUsersByName(String name) {
    return entityManager.createQuery("SELECT u FROM User u WHERE u.name = :name", User.class)
                        .setParameter("name", name)
                        .getResultList();
}
~~~

---

## 스프링 테스트 정리

### 단위 테스트 (Unit Test)
* 개별 모듈 또는 구성 요소를 테스트
* 목적
  * 개별 모듈 또는 클래스의 동작을 검증
  * 코드의 특정 부분이 예상대로 동작하는지 확인
* 범위
  * 주로 하나의 메서드나 클래스
  * 외부 의존성(Mock 객체 사용)은 제거하고 테스트

### 통합 테스트 (Integration Test)
* 여러 모듈 또는 구성 요소가 함께 작동하는지 테스트.(데이터베이스, 외부 API 등과의 상호작용도 포함)
* 목적
  * 여러 모듈 또는 클래스가 함께 올바르게 동작하는지 검증
  * 데이터베이스, 외부 API 등과의 상호작용을 포함
* 범위
  * 여러 클래스나 모듈 간의 상호작용
  * 실제 의존성을 사용하여 테스트

```통합 테스트에서 실제 빈을 띄울 때 주의할 점 : 데이터 베이스 격리 - Transactional 어노테이션을 사용하여 테스트가 끝난 후 롤백진행.```


### E2E 테스트 (End-to-End Test)
* 사용자 관점에서 시스템의 전체 워크플로우를 테스트
* 목적
  * 실제 사용자의 관점에서 예상대로 작동하는지 확인
  * 플리케이션의 모든 구성 요소(프론트엔드, 백엔드, 데이터베이스, 외부 서비스 등)가 통합되어 제대로 동작하는지 확인. (단위 테스트나 통합 테스트로는 확인 어려운 것들 확인 가능)
* 범위
  * 프론트엔드, 백엔드, 데이터베이스, 외부서버 등등..

### 실제 빈을 띄우는 테스트와 Stub/Fake/Mock을 이용한 테스트

#### 실제 빈을 띄우는 테스트 - 통합테스트, 컨트롤러 테스트
* 실제 환경과 유사한 조건에서 테스트
* 모든 스프링 기능(AOP, 트랜잭션 등) 테스트 가능
* 설정과 실행 시간이 길어질 수 있음
* 외부 시스템의 상태에 따라 테스트 결과가 달라질 수 있음

#### Stub/Fake/Mock을 이용한 테스트 - 단위테스트
* 빠르고 간단하게 테스트 가능
* 외부 시스템의 의존성을 제거하여 독립적 테스트 가능
* 실제 환경과 다를 수 있음
* Mock 객체 설정이 복잡할 수 있음


### 테스트 격리
* 각 테스트가 독립적으로 실행되어 다른 테스트의 결과나 상태에 영향을 받지 않도록 하는 것을 의미한다. 

1. 도메인 -> 단위테스트 진행 : 알아서 격리 됌. @BeforEach로 객체 생성 가능하기 때문.
2. 서비스 -> Mock + @Transactional 이용 
3. 컨트롤러 -> @WebMvcTest 어노테이션을 사용해서 SpringMvc에 필요한 빈들만 사용, @DataJpaTest라는 어노테이션을 사용해서 데이터 계층에 관련된 빈들만 가지고 slice테스트를 할 수 있음.

### TestFixture
* Test Fixture는 테스트를 실행하기 전에 설정해야 하는 초기 상태나 환경을 의미. 주로 객체를 생성하는데 많이 이용.

**사용법**
1. @BeforEach 사용해서 객체 setUp, @AfterEach 사용해서 객체 delete
2. Fixture 패키지 -> MemberFixture -> 정적 팩토리 메서드로 객체 생성.

### @MockMvc(Controller 테스트)
* @AutoConfigureMockMvc 어노테이션을 사용하여 구성할 수도 있다. but 이 접근 방식은 Spring Boot가 전체 애플리케이션 컨텍스트를 실행하도록 요구하므로 테스트 실행 속도가 느려질 수 있음.
1. ArticleController 컨트롤러에 대해서만 컨텍스트를 인스턴스화하도록 지정
~~~
@WebMvcTest(ArticleController.class)
class ArticleControllerUnitTest {
    @Autowired
    private MockMvc mockMvc;
}
~~~

2. 객체로 응답 받는 법 - 엔트포인트: /article
~~~
MvcResult result = this.mockMvc.perform(get("/article"))
  .andExpect(status().isOk())
  .andReturn();
~~~

3. 원하는 문자열로 응답 받는 법 - objectMapper 이용
~~~
String json = result.getResponse().getContentAsString();
Article article = objectMapper.readValue(json, Article.class);

assertNotNull(article);
assertEquals(1L, article.getId());
assertEquals("Learn Spring Boot", article.getTitle());
~~~

4. 객체 컬렉션 얻는 법 - TypeReference 제네릭 클래스를 사용
~~~
@Test
void whenGetArticle_thenReturnListUsingJacksonTypeReference() throws Exception {
    MvcResult result = this.mockMvc.perform(get("/articles"))
      .andExpect(status().isOk())
      .andReturn();

    String json = result.getResponse().getContentAsString();
    List<Article> articles = objectMapper.readValue(json, new TypeReference<>(){});

    assertNotNull(articles);
    assertEquals(2, articles.size());
}
~~~
---
