## Spring annotation 정리

## 핵심 어노테이션

1. @SpringBootApplication
    - Spring boot 애플리케이션의 진입점으로 사용
    - @Configuration, @EnableAutoConfiguration, @ComponentScane을 포함한다

2. @Component:
    - 자동으로 빈으로 등록되도록 지정
    - 주로 서비스나 레포지토리 클래스에 사용된다.
    - Spring 컨테이너가 이 클래스를 빈으로 관리하게 한다.

3. @Service
    - @Component 와 동일 서비스 계층에 사용되는 클래스에 의미를 부여한다.
    - 비즈니스 로직을 처리하는 서비스 계층을 명확히한다.
    - 구분 짓기 위해 사용하는 느낌이다!


4. @Repository
    - @Component와 동일하지만, 데이터 액세스 계층에 사용되는 클래스에 의미를 부여하고
    - 데이터 엑세스 예외로 변환한다.
    - 데이터베이스 예외를 스프링의 데이터 액세스 예외로 변환한다.


5. @Controller
    - MVC에서 컨트롤러 역할을 하는 클래스에 사용한다.
    -  웹 요청을 처리하고 뷰를 반환하는 컨트롤러로 동작하는듯

6. @RestController
    - Controller와 @ResponseBody의 조합으로
    - RESTful 웹 서비스 컨트롤러에 사용된다.
    - JSON/XML 형식의 데이터를 반환

7. @Configuration:
    - 자바 기반 설정 파일을 나타낸다. 빈 정의를 포함할 수있다.

8. @Bean :
    - 메서드 레벨에서 사용되어 반환된 객체를 Spring의 빈으로 등록

---
### Bean과 Component의 차이점

- 개요
  - 스프링은 개발의 제어권이 IoC Container에 있음. 따라서 스프링이 개발자 대신 객체를 제어하기 위해서는 객체들이 빈(@Bean)으로 등록되어 있어야 한다.
  - 그래서 @Controller, @Service 등으로 빈으로 등록하며 Configuration 관련 객체들은 @Bean 과 @Component 로 등록.

- @Bean : 메소드 레벨에서 선언하며, 객체를 개발자가 수동으로 빈으로 등록하는 어노테이션이다.
- @Component : 클래스 레벨에서 선언하며, 스프링이 런타임시에 컴포넌트 스캔을 하여 자동으로 빈을 찾고 등록하는 어노테이션이다.


---
### Controller와 RestController의 차이점 

- @Controller는 데이터를 객체를 반환할 때, 일반적인 경우 @Responsebody + @ResponseEntity를 활용하여 객체 반환
- @Restcontroller는 @Controller + @Responsebody 가 합쳐진 어노테이션이므로 @ResponseEntity만을 사용하여 객체 반환(반환 형태는 주로 JSON)

## 주로 CustomException 만들 때 쓰이는 어노테이션

1. @RestControllerAdvice
   - @ControllerAdvice에 @ResponseBody를 더해 응답을 json 형태로 사용자 정의가 가능
   - @ControllerAdvice : @Component 어노테이션의 특수한 케이스로, 스프링 부트 애플리케이션에서 전역적으로 예외를 핸들링할 수 있게 해주는 어노테이션.

2. @ExceptionHandler
   - value로 원하는 예외를 지정하고 이를 핸들링 할 수 있음.
   - value 속성으로 지정한 예외뿐 아니라 예외의 자식 클래스도 전부 캐치해 지정된 응답을 반환.

3. @SLf4j
   - 스프링 부트에서 로그 남기게 해주는 어노테이션.
---
## 의존성 주입

1. @Autowired :
    - 의존성 주입을 위한 애노테이션
    - 생성자, 필드, 메서드에 적용

2. @Qualifier:
    - @Autowired와 같이 사용
    - 명시적으로 주입할 때 사용
    - EX) @Qualifier("mySpecificService")
    - 주입할 빈을 이름으로 명시할 수 있음 코드 명확성을 위한 것인가?

3. @inject
    - javax.inject 패키지에서 제공
    - @Autowired 와 비슷

4. @Resource
    - @Autowired 와 비슷함
    - @Resource(name = "myService")
      private MyService myService;
    - 이런식으로 빈의 이름을 사용하여 주입


## Spring MVC 어노테이션 :


1. @RequestMapping
    - URL 요청을 처리할 메서드나 클래스에 매핑한다.
    - 지정된 경로에 대한 요청을 해당 메서드로 매핑

2. @GetMapping @PostMapping @PutMapping, @DeleteMapping, @PatchMapping

    - HTTP 메서드와 URL을 매핑한다.
    - @RequestMapping 의 축약형

3. @PathVariable
    - URL 경로에서 변수를추출하여 메서드 파라미터에 바인딩한다.
    - URL 경로의 변수를 메서드 파라미터로 추출한다.

    - 사용법
      - @GetMapping("/{name}")
        public ~ (@PathVariable String name)
      - 다양한 사용법이 있지만 요런식으로 위처럼 사용되어짐

4. @RequestParam
    - 요청 파라미터를 메서드 파라미터에 바인딩한다.

    - 사용법
      - @GetMapping("/")
        public ~ (@RequestParam name = "name" String name)
      - 다양한 사용법이 있지만 요런식으로 위처럼 사용되어짐
      
   - 중요!!
     - params 속성 사용(엔드포인트 같을 때 사용해야 하는듯.):
       - 특정 매개변수의 존재 여부에 따라 다른 메서드로 매핑.
       - 복수의 메서드를 정의할 때 유용.
       
     - params 속성 사용 X : 
       - 요청 매개변수를 메서드의 매개변수로 직접 매핑.
       - 단일 메서드 내에서 여러 매개변수를 처리할 수 있음.
       - 매개변수를 필수 또는 선택 사항으로 지정 가능.
---
### RequestParam, PathVariable 차이

- @PathVariable은 @RequestParam과 다르게 default 값을 설정하지 않으므로 만약 default 값이 필요한 조회 요청을 한다면 @RequestParam을 사용하여 구현하면 되고, 앞서 보여주었던 예제와 같이 id와 같이 필수로 입력되어야 하는 값이라면 @PathVariable을 사용하여 구현하면 됌.
---

5. @RequestBody
    - 요청 본문을 메서드 파라미어테 바인딩한다.

6. @ResponseBody
    - 메서드의 반환 값을 HTTP 응답 본문으로 변환합니다.(클라이언트에게)

7. @ResponseEntity
   - 일반적으로 객체를 return 하면, Http 응담을 제어할 수 없음. 따라서 @ResponseEntity 사용.
   - return 값에 Http의 header, body를 실어보낼 수 있음.

   1. ResponseEntity.status(HttpStatus.CREATED).build() : HTTP 상태 코드만 설정하고 바디나 헤더는 포함하지 않는 방식
      ~~~
      @PostMapping("/members")
      public ResponseEntity<Void> createUser() {
      // 사용자 생성 로직
      return ResponseEntity.status(HttpStatus.CREATED).build();
      }
      ~~~
      
   2. ResponseEntity.created(URI).build() : HTTP 상태 코드 201 Created와 함께 Location 헤더에 새로 생성된 리소스의 URI를 포함하는 방식
      ~~~
      @PostMapping("/members")
      public ResponseEntity<Void> createUser(@RequestBody User member) {
      // 사용자 생성 로직
      URI location = URI.create("/members/" + member.getId());
      return ResponseEntity.created(location).build();
      }
      ~~~
      해당 URI 접속하면 사용자 정보를 조회할 수 있음.


8. @JsonAnyGetter
   - JsonAnyGetter 는 Map 필드를 다루는데 유연성을 제공

9. @JsonGetter
   - @JsonProperty를 대체하여 getter 메소드 위에 사용

10. @JsonPropertyOrder
    - Json Serialization을 했을 경우에 프로퍼티가 출력되는 순서를 지정

11. @JsonValue
   - JSON의 리턴 값을 어떤 규격화 된 포맷으로 리턴하고 싶을 때 사용하면 유용
   - 한 클래스 내에서 한번만 사용
   - 함수 위에 사용하며, 해당 함수의 리턴값으로 JSON이 Serialization

---
## Spring Data JPA 어노테이션


1. @Entity
    - JPA 엔티티 클래스를 지정

2. @Table
    - 엔티티와 매핑할 데이터베이스 테이블을 지정한다.



빈으로 관리한다는 것이 무엇일까? 에 대한 공부

1. 객체의 생명 주기를 컨테이너가 관리하고
2. 필요할 때 객체를 주입하거나 사용할 수 있도록 해준다
3. 의존성 주입을 통해 이루어진다.
4. 개발자가 객체의 생성의 관여하지않고 Spring이 해주는 것이다.
5. 빈으로 등록된 객체는 애플리케이션 전역에서 재사용가능 싱글턴 패턴으로 관리


